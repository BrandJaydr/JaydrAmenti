"""
Exploit Database Integration
Correlates discovered services with known vulnerabilities and exploits
"""

import json
import time
import requests
import os
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

@dataclass
class Vulnerability:
    """Vulnerability information structure"""
    cve_id: str
    severity: str
    score: float
    description: str
    affected_versions: List[str]
    exploit_available: bool = False
    exploit_references: List[str] = None
    mitigation: str = ""
    
    def __post_init__(self):
        if self.exploit_references is None:
            self.exploit_references = []

@dataclass
class ExploitInfo:
    """Exploit information structure"""
    exploit_id: str
    title: str
    description: str
    type: str  # remote, local, web, etc.
    platform: str
    references: List[str]
    difficulty: str  # easy, medium, hard
    reliability: str  # excellent, great, good, normal, low
    author: str = ""
    date_published: str = ""
    
    def __post_init__(self):
        if self.references is None:
            self.references = []

class ExploitDatabase:
    def __init__(self):
        self.console = Console()
        self.vulnerabilities = {}
        self.exploits = {}
        self.service_mappings = {}
        
        # CVE API endpoint
        self.cve_api_base = "https://cve.circl.lu/api"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json"
        
        # Load local exploit database
        self.load_local_database()
        
        # Service to CVE mappings for common services
        self.service_cve_patterns = {
            'apache': ['apache', 'httpd'],
            'nginx': ['nginx'],
            'openssh': ['openssh', 'ssh'],
            'mysql': ['mysql'],
            'postgresql': ['postgresql', 'postgres'],
            'microsoft-ds': ['samba', 'smb', 'microsoft'],
            'ftp': ['vsftpd', 'proftpd', 'pureftpd'],
            'telnet': ['telnet'],
            'smtp': ['postfix', 'sendmail', 'exim'],
            'dns': ['bind', 'dnsmasq'],
            'snmp': ['net-snmp'],
            'rdp': ['terminal services', 'rdp'],
            'vnc': ['vnc', 'tightvnc', 'realvnc']
        }
    
    def load_local_database(self):
        """Load local exploit database if available"""
        try:
            # This would load from a local database file
            # For now, we'll populate with some common examples
            self.populate_sample_database()
        except Exception as e:
            self.console.print(f"[yellow]Warning:[/yellow] Could not load local database: {e}")
    
    def populate_sample_database(self):
        """Populate database with sample vulnerabilities and exploits"""
        # Common vulnerabilities for demonstration
        sample_vulns = [
            {
                'cve_id': 'CVE-2021-44228',
                'severity': 'critical',
                'score': 10.0,
                'description': 'Apache Log4j2 Remote Code Execution',
                'affected_versions': ['log4j 2.0-2.14.1'],
                'exploit_available': True,
                'exploit_references': ['EDB-50592', 'MSF-exploit/multi/http/log4j_header_injection'],
                'mitigation': 'Upgrade to Log4j 2.15.0 or later'
            },
            {
                'cve_id': 'CVE-2017-0144',
                'severity': 'critical',
                'score': 8.1,
                'description': 'Windows SMB Remote Code Execution (EternalBlue)',
                'affected_versions': ['Windows 7', 'Windows Server 2008', 'Windows Server 2012'],
                'exploit_available': True,
                'exploit_references': ['EDB-42315', 'MSF-exploit/windows/smb/ms17_010_eternalblue'],
                'mitigation': 'Apply MS17-010 security update'
            },
            {
                'cve_id': 'CVE-2014-6271',
                'severity': 'critical',
                'score': 10.0,
                'description': 'Bash Shellshock Remote Code Execution',
                'affected_versions': ['bash 1.14-4.3'],
                'exploit_available': True,
                'exploit_references': ['EDB-34766', 'MSF-exploit/multi/http/apache_mod_cgi_bash_env_exec'],
                'mitigation': 'Update bash to patched version'
            }
        ]
        
        for vuln_data in sample_vulns:
            vuln = Vulnerability(**vuln_data)
            self.vulnerabilities[vuln.cve_id] = vuln
        
        # Sample exploits
        sample_exploits = [
            {
                'exploit_id': 'EDB-50592',
                'title': 'Apache Log4j 2.15.0 - Remote Code Execution',
                'description': 'Remote code execution via JNDI injection in log4j',
                'type': 'remote',
                'platform': 'java',
                'references': ['https://www.exploit-db.com/exploits/50592'],
                'difficulty': 'easy',
                'reliability': 'excellent',
                'author': 'Various',
                'date_published': '2021-12-10'
            },
            {
                'exploit_id': 'EDB-42315',
                'title': 'Microsoft Windows - SMB Remote Code Execution Scanner',
                'description': 'Scanner and exploit for MS17-010 EternalBlue vulnerability',
                'type': 'remote',
                'platform': 'windows',
                'references': ['https://www.exploit-db.com/exploits/42315'],
                'difficulty': 'medium',
                'reliability': 'great',
                'author': 'worawit',
                'date_published': '2017-05-30'
            }
        ]
        
        for exploit_data in sample_exploits:
            exploit = ExploitInfo(**exploit_data)
            self.exploits[exploit.exploit_id] = exploit
    
    def search_vulnerabilities_by_service(self, service_name: str, version: str = None) -> List[Vulnerability]:
        """Search for vulnerabilities affecting a specific service"""
        vulnerabilities = []
        
        try:
            # Normalize service name
            service_lower = service_name.lower()
            
            # Search local database first
            local_vulns = self._search_local_vulnerabilities(service_lower, version)
            vulnerabilities.extend(local_vulns)
            
            # Search online databases if available
            try:
                online_vulns = self._search_online_vulnerabilities(service_name, version)
                vulnerabilities.extend(online_vulns)
            except Exception as e:
                self.console.print(f"[yellow]Warning:[/yellow] Online search failed: {e}")
            
            # Remove duplicates based on CVE ID
            seen_cves = set()
            unique_vulns = []
            for vuln in vulnerabilities:
                if vuln.cve_id not in seen_cves:
                    seen_cves.add(vuln.cve_id)
                    unique_vulns.append(vuln)
            
            return sorted(unique_vulns, key=lambda v: v.score, reverse=True)
            
        except Exception as e:
            self.console.print(f"[red]Error searching vulnerabilities:[/red] {e}")
            return []
    
    def _search_local_vulnerabilities(self, service_name: str, version: str = None) -> List[Vulnerability]:
        """Search local vulnerability database"""
        matching_vulns = []
        
        for vuln in self.vulnerabilities.values():
            # Check if service name appears in description or affected versions
            description_lower = vuln.description.lower()
            
            # Look for service patterns
            service_patterns = self.service_cve_patterns.get(service_name, [service_name])
            
            for pattern in service_patterns:
                if pattern in description_lower:
                    # Check version if provided
                    if version:
                        version_match = self._check_version_affected(vuln, version)
                        if version_match:
                            matching_vulns.append(vuln)
                    else:
                        matching_vulns.append(vuln)
                    break
        
        return matching_vulns
    
    def _search_online_vulnerabilities(self, service_name: str, version: str = None) -> List[Vulnerability]:
        """Search online vulnerability databases"""
        vulnerabilities = []
        
        try:
            # Search CVE database
            search_query = f"{service_name}"
            if version:
                search_query += f" {version}"
            
            # This would make actual API calls to vulnerability databases
            # For demonstration, we'll return empty list
            # In production, implement actual API calls to:
            # - NVD API
            # - CVE Details
            # - VulnDB
            # - etc.
            
            return vulnerabilities
            
        except Exception as e:
            raise Exception(f"Online vulnerability search failed: {e}")
    
    def _check_version_affected(self, vulnerability: Vulnerability, version: str) -> bool:
        """Check if a specific version is affected by the vulnerability"""
        if not vulnerability.affected_versions:
            return True  # Assume affected if no version info
        
        # Simple version matching - in production, implement proper version comparison
        version_lower = version.lower()
        for affected_version in vulnerability.affected_versions:
            if version_lower in affected_version.lower():
                return True
        
        return False
    
    def correlate_scan_results(self, scan_results: Dict) -> Dict[str, List[Vulnerability]]:
        """Correlate scan results with vulnerability database"""
        correlations = {}
        
        if not scan_results.get('parsed_results'):
            return correlations
        
        hosts = scan_results['parsed_results'].get('hosts', [])
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            task = progress.add_task("Correlating vulnerabilities...", total=len(hosts))
            
            for host_data in hosts:
                host_ip = self._extract_host_ip(host_data)
                host_vulns = []
                
                # Analyze each service
                ports = host_data.get('ports', [])
                for port_data in ports:
                    if port_data.get('state', {}).get('state') == 'open':
                        service_info = port_data.get('service', {})
                        service_name = service_info.get('name', '')
                        service_product = service_info.get('product', '')
                        service_version = service_info.get('version', '')
                        
                        # Search for vulnerabilities
                        if service_name:
                            vulns = self.search_vulnerabilities_by_service(service_name, service_version)
                            host_vulns.extend(vulns)
                        
                        if service_product and service_product != service_name:
                            vulns = self.search_vulnerabilities_by_service(service_product, service_version)
                            host_vulns.extend(vulns)
                
                # Remove duplicates
                unique_vulns = list({v.cve_id: v for v in host_vulns}.values())
                correlations[host_ip] = unique_vulns
                
                progress.advance(task)
        
        return correlations
    
    def _extract_host_ip(self, host_data: Dict) -> str:
        """Extract IP address from host data"""
        addresses = host_data.get('addresses', [])
        for addr in addresses:
            if addr.get('addrtype') == 'ipv4':
                return addr.get('addr')
        return 'unknown'
    
    def get_exploits_for_vulnerability(self, cve_id: str) -> List[ExploitInfo]:
        """Get available exploits for a specific vulnerability"""
        exploits = []
        
        # Check if vulnerability has exploit references
        if cve_id in self.vulnerabilities:
            vuln = self.vulnerabilities[cve_id]
            for exploit_ref in vuln.exploit_references:
                if exploit_ref in self.exploits:
                    exploits.append(self.exploits[exploit_ref])
        
        # Search local exploit database
        for exploit in self.exploits.values():
            if cve_id.lower() in exploit.description.lower() or cve_id.lower() in exploit.title.lower():
                if exploit not in exploits:
                    exploits.append(exploit)
        
        return exploits
    
    def generate_vulnerability_report(self, correlations: Dict[str, List[Vulnerability]]) -> Table:
        """Generate vulnerability report table"""
        table = Table(title="Vulnerability Analysis Report")
        table.add_column("Host", style="cyan")
        table.add_column("CVE ID", style="yellow")
        table.add_column("Severity", style="red")
        table.add_column("Score", style="white")
        table.add_column("Description", style="white", max_width=50)
        table.add_column("Exploit", style="green")
        
        for host_ip, vulnerabilities in correlations.items():
            if not vulnerabilities:
                table.add_row(host_ip, "No vulnerabilities found", "N/A", "N/A", "N/A", "N/A")
                continue
            
            for i, vuln in enumerate(vulnerabilities):
                host_display = host_ip if i == 0 else ""
                
                severity_style = self._get_severity_style(vuln.severity)
                exploit_status = "✓ Available" if vuln.exploit_available else "✗ None"
                
                table.add_row(
                    host_display,
                    vuln.cve_id,
                    f"[{severity_style}]{vuln.severity.upper()}[/{severity_style}]",
                    f"{vuln.score:.1f}",
                    vuln.description[:50] + "..." if len(vuln.description) > 50 else vuln.description,
                    exploit_status
                )
        
        return table
    
    def _get_severity_style(self, severity: str) -> str:
        """Get Rich style for vulnerability severity"""
        severity_styles = {
            'critical': 'bold red',
            'high': 'red',
            'medium': 'yellow',
            'low': 'green',
            'info': 'blue'
        }
        return severity_styles.get(severity.lower(), 'white')
    
    def get_exploit_summary_table(self, exploit: ExploitInfo) -> Table:
        """Generate summary table for exploit information"""
        table = Table(title=f"Exploit Details: {exploit.exploit_id}")
        table.add_column("Attribute", style="cyan")
        table.add_column("Value", style="white")
        
        table.add_row("Exploit ID", exploit.exploit_id)
        table.add_row("Title", exploit.title)
        table.add_row("Type", exploit.type.title())
        table.add_row("Platform", exploit.platform.title())
        table.add_row("Difficulty", exploit.difficulty.title())
        table.add_row("Reliability", exploit.reliability.title())
        table.add_row("Author", exploit.author)
        table.add_row("Date Published", exploit.date_published)
        table.add_row("References", "\n".join(exploit.references))
        
        return table
    
    def export_vulnerability_data(self, correlations: Dict[str, List[Vulnerability]]) -> Dict:
        """Export vulnerability correlation data"""
        export_data = {
            'timestamp': time.time(),
            'correlations': {}
        }
        
        for host_ip, vulnerabilities in correlations.items():
            export_data['correlations'][host_ip] = []
            
            for vuln in vulnerabilities:
                vuln_data = {
                    'cve_id': vuln.cve_id,
                    'severity': vuln.severity,
                    'score': vuln.score,
                    'description': vuln.description,
                    'affected_versions': vuln.affected_versions,
                    'exploit_available': vuln.exploit_available,
                    'exploit_references': vuln.exploit_references,
                    'mitigation': vuln.mitigation
                }
                export_data['correlations'][host_ip].append(vuln_data)
        
        return export_data
    
    def update_vulnerability_database(self) -> bool:
        """Update local vulnerability database from online sources"""
        try:
            self.console.print("[cyan]Updating vulnerability database...[/cyan]")
            
            # This would implement actual database updates from:
            # - NVD feeds
            # - CVE databases
            # - Exploit databases
            # - Vendor advisories
            
            # For demonstration, just update timestamp
            self.last_update = time.time()
            
            self.console.print("[green]✓[/green] Database update completed")
            return True
            
        except Exception as e:
            self.console.print(f"[red]Error updating database:[/red] {e}")
            return False
    
    def search_exploits(self, query: str) -> List[ExploitInfo]:
        """Search exploit database by query"""
        matching_exploits = []
        query_lower = query.lower()
        
        for exploit in self.exploits.values():
            # Search in title, description, and platform
            searchable_text = f"{exploit.title} {exploit.description} {exploit.platform}".lower()
            
            if query_lower in searchable_text:
                matching_exploits.append(exploit)
        
        return sorted(matching_exploits, key=lambda e: e.date_published, reverse=True)
    
    def get_statistics(self) -> Dict:
        """Get vulnerability database statistics"""
        stats = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'total_exploits': len(self.exploits),
            'severity_breakdown': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0},
            'exploitable_vulns': 0
        }
        
        for vuln in self.vulnerabilities.values():
            severity = vuln.severity.lower()
            if severity in stats['severity_breakdown']:
                stats['severity_breakdown'][severity] += 1
            
            if vuln.exploit_available:
                stats['exploitable_vulns'] += 1
        
        return stats
